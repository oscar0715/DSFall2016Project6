package pit;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import javax.jms.*;
import javax.naming.*;

/*
 * This is the ONLY file that you are to edit.  It is the model of play for
 * every PITplayer.  Each PITplayer instantiates this model and uses it to
 * process the messages it receives.
 */
public class PITPlayerModel {

    // Each PITplayer has a unique myPlayerNumber.  It is set in the PITPlayer constructor.
    private int myPlayerNumber;
    // Cards is this player's set of cards.  
    private final ArrayList cards = new ArrayList();
    // numTrades counts trades.
    private int numTrades = 0;
    // maxTrades is the maximum number of trades, after which trading is stopped.
    private final int maxTrades = 20000;
    // numPlayers are the number of Players trading.  This comes with a NewHand from the PITsnapshot servlet
    private int numPlayers = 0;
    // halting indicates that the system is being reset, so ignore trades unti a new had received.
    private boolean halting = false;

    /* The snapshot servlet (PITsnapshot) is expecting to be passed an ObjectMessage
     * where the object is a HashMap. Therefore this definition of that HashMap is 
     * provided although it is not currently used (it is for you to use).
     * PITsnapshot is expecting a set of attibute/value pairs.  These include the player
     * number, as in state.put("Player", myPlayerNumber), and each commodity string
     * and the number of that commodity in the snapshot.
     * Also included below is a utility method that will turn a HashMap into a string
     * which is useful for printing diagnostic messages to the console.
     */
    private HashMap<String, Integer> state;

    // use a hashmap to flag whether an incoming channel is marked
    private HashMap<Integer, Boolean> incoming;

    // use a variable to flag the start of the algorithm
    private boolean isStarted = false;

    // PITPlayerModel constructor saves what number player this object represents.
    PITPlayerModel(int myNumber) {
        myPlayerNumber = myNumber;

        state = new HashMap<>();
        incoming = new HashMap<>();
    }

    public void onMessage(Message message) {
        try {
            if (message instanceof ObjectMessage) {
                Object o = ((ObjectMessage) message).getObject();

                // There are 4 types of messages:  Reset, NewHand, Trade, and Marker
                // Reset the Player.  The Reset message is generated by the PITsnapshot servlet
                if (o instanceof Reset) {
                    doReset((Reset) o);

                    // NewHand received from PITsnapshot
                } else if (o instanceof NewHand) {
                    // Add the new hand into cards
                    doNewHand((NewHand) o);

                    // Receive a Trade from another Player
                } else if (o instanceof Trade) {

                    // Add the trade into cards
                    doReceiveTrade((Trade) o);

                } else if (o instanceof Marker) {
                    Marker marker = (Marker) o;
                    if (!isStarted) {
                        // The first time to receive a marker
                        doStart(marker);
                    } else {
                        doEndChannel(marker);
                    }
                } else {
                    System.out.println("PITplayer" + myPlayerNumber + " received unknown Message type");
                    // just ignore it
                }
            }
        } catch (Exception e) {
            System.out.println("Exception thrown in PITplayer" + myPlayerNumber + ": " + e);
        }
    }

    // start the algorithm 
    private void doStart(Marker marker) throws Exception {
        // get source player
        int source = marker.source;

        // mark start
        isStarted = true;

        // init the map flag the incoming channel
        for (int i = 0; i < numPlayers; i++) {
            incoming.put(i, false);
        }
        incoming.put(myPlayerNumber, true);

        // mark this source channel
        if (source != -1) {
            incoming.put(source, true);
        }

        Marker newMarker = new Marker(myPlayerNumber);
        for (int i = 0; i < numPlayers; i++) {
            if (i != myPlayerNumber) {
                String sendToJNDI = "jms/PITplayer" + i;
                sendToQueue(sendToJNDI, newMarker);
            }
        }

        // Record my state
        state.putAll(recordMyState());

    }

    private HashMap<String, Integer> recordMyState() {

        // create a map
        HashMap<String, Integer> mystate = new HashMap<>();

        // count the number of cards I have
        int cardsNum = cards.size();

        for (int i = 0; i < cardsNum; i++) {
            if (cards.get(i) instanceof String) {
                String card = (String) cards.get(i);
                addCard(mystate, card);
            }
        }

        // put my identity
        mystate.put("Player", myPlayerNumber);
        return mystate;
    }
    
    // a help method 
    private void addCard(HashMap<String, Integer> map, String card) {
        if (map.containsKey(card)) {
            map.put(card, 1 + map.get(card));
        } else {
            map.put(card, 1);
        }
    }

    private void doEndChannel(Marker marker) throws Exception {
        // if we have received marker before 
        
        int source = marker.source;
        incoming.put(source, true);

        // check if this node complete this algorithm
        if (checkTermination()) {
            // if all completed 
            // send the state to the snapshot queue
            String sendToJNDI = "jms/PITsnapshot";
            System.out.println("[Report state] = player " + myPlayerNumber);
            // System.out.println("[incoming] = " + incoming);
            sendToQueue(sendToJNDI, state);
            resetSnapshot();
        }
    }

    private boolean checkTermination() {
        // check if we have received markers form all of the channels 
        Set<Integer> keys = incoming.keySet();
        for (Integer key : keys) {
            if (!incoming.get(key)) {
                return false;
            }
        }
        return true;
    }

    private void resetSnapshot() {
        // reset start mark
        isStarted = false;

        // clear state 
        state.clear();

        // reset incoming map
        for (int i = 0; i < numPlayers; i++) {
            incoming.put(i, false);
        }
        incoming.put(myPlayerNumber, true);
    }

    private void doReset(Reset reset) throws Exception {
        if (reset.action == Reset.HALT) {
            System.out.println("PITplayer" + myPlayerNumber + " received Reset HALT");
            halting = true;
            // Reply to the PITsnapshot servlet acknowledging the Reset HALT
            sendToQueue("jms/PITmonitor", reset);
        } else { // action == Reset.CLEAR
            System.out.println("PITplayer" + myPlayerNumber + " received Reset RESET");
            // Drop all cards in hand
            cards.clear();
            numTrades = 0;
            numPlayers = 0;
            halting = false;
            // Reply to the PITsnapshot servlet acknowledging the Reset
            sendToQueue("jms/PITmonitor", reset);
        }
    }

    private void doNewHand(NewHand hand) throws Exception {
        // Add new hand cards.  
        // It is actually possible that a trade had added a card already.
        cards.addAll((hand).newHand);
        numPlayers = (hand).numPlayers;
        System.out.println("PITplayer" + myPlayerNumber + " new hand: " + toString(cards));
        // Trade away a card
        doMakeTrade();
    }

    private void doReceiveTrade(Trade trade) throws Exception {
        if (halting) {
            return; // if halting, discard trade
        }
        // Having received a Trade card from another Player, add it to my hand of cards
        cards.add(trade.tradeCard);
        
        String card = trade.tradeCard;
        // get the source 
        int source = trade.sourcePlayer;
        if (isStarted && !incoming.get(source + "")) {
            // if the algorithm is stated 
            // and we have not received a Marker from this channel
            // we should count this trade 
            addCard(state, card);
        }
        

        System.out.println("PITplayer" + myPlayerNumber + " received: " + trade.tradeCard + " from player: " + trade.sourcePlayer);
        System.out.println("PITplayer" + myPlayerNumber + " hand: " + toString(cards));
        // Trade away a card
        doMakeTrade();
    }

    private void doMakeTrade() throws Exception {

        // if hit maxTrades limit, then stop sending trades
        if (maxTrades(maxTrades)) {
            return;
        }

        /*
         * If numPlayers == 0, while we have received a Trade, we have not 
         * received our NewHand yet, so we don't know how many players there 
         * are.  Therefore, don't send out a Trade at this time.
         * 
         */
        if (numPlayers == 0) {
            return;
        }

        // Create a new Trade from my set of cards, and send to another player
        Trade newTrade = new Trade();
        newTrade.tradeCard = (String) cards.remove(0);
        newTrade.sourcePlayer = myPlayerNumber;

        // Find a random player to trade to (not including myself)
        int sendTo = myPlayerNumber;
        while (sendTo == myPlayerNumber) {
            sendTo = Math.round((float) Math.random() * (numPlayers - 1));
        }

        //Send the card to the other player
        System.out.println("PITplayer" + myPlayerNumber + " sending: " + newTrade.tradeCard + " to player: " + sendTo);
        String sendToJNDI = "jms/PITplayer" + sendTo;
        sendToQueue(sendToJNDI, newTrade);

    }

    // Create a string of hand size and all cards to use in printing
    private String toString(ArrayList hand) {

        String cardsString = "size: " + hand.size() + " ";
        for (int i = 0; i < hand.size(); i++) {
            cardsString += hand.get(i) + " ";
        }
        return cardsString;
    }

    // Create a printable version of the "state".
    private String toString(HashMap<String, Integer> state) {
        String stateString = "";
        for (Iterator it = state.entrySet().iterator(); it.hasNext();) {
            Map.Entry entry = (Map.Entry) it.next();
            String commodity = (String) entry.getKey();
            int number = ((Integer) entry.getValue()).intValue();
            stateString += "{" + commodity + ":" + number + "} ";
        }
        return stateString;
    }

    // Send an object to a Queue, given its JNDI name
    private void sendToQueue(String queueJNDI, Serializable message) throws Exception {
        // Gather necessary JMS resources
        Context ctxt = new InitialContext();
        Connection con = ((ConnectionFactory) ctxt.lookup("jms/myConnectionFactory")).createConnection();
        Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
        Queue q = (Queue) ctxt.lookup(queueJNDI);
        MessageProducer writer = session.createProducer(q);
        ObjectMessage msg = session.createObjectMessage(message);
        // Send the object to the Queue
        writer.send(msg);
        session.close();
        con.close();
        ctxt.close();
    }

    // Stop trading when the max number of Trades is reached
    private boolean maxTrades(int max) {
        if ((numTrades % 100) == 0) {
            System.out.println("PITplayer" + myPlayerNumber + " tradeCount: " + numTrades);
        }
        return (numTrades++ < max) ? false : true;
    }
}
